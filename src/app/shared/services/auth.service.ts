// src/app/services/auth.service.ts
import { Injectable, signal } from '@angular/core';
import { Router } from '@angular/router';
import { tap } from 'rxjs';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import {Usuario} from '../interfaces/usuario.models';
import * as CryptoJS from 'crypto-js';

import { environment } from '../../../environments/environment';
import { CookieService } from './cookie.service';



declare const google: any; // para revoke/cancel opcional

@Injectable({ providedIn: 'root' })
export class AuthService {
  // Se√±al para el usuario (tu template usa user(); perfecto)
  private userSignal = signal<Usuario | null>(null);
  public user = this.userSignal.asReadonly();

  // No lo dejes hardcodeado luego; lee de env o config.
  private apiUrl = 'http://localhost:4000/graphql';

  private secret = environment.COOKIE_SECRET;
  private userCookieName = environment.USER_COOKIE_NAME;

  constructor(
    private http: HttpClient,
    private router: Router,
    private cookieService: CookieService
    ) {}
  /** Estado simple de UI (no consulta cookie httpOnly) */
  public isAuthenticated(): boolean {
      let auth:boolean=false;
      const encrypted :string | null = this.cookieService.getCookie(this.userCookieName);
      if (!encrypted) {
        console.warn('‚ùå No existe cookie de sesi√≥n');
        return auth;
      }

      try {
        // üîì Descifrar cookie
        const bytes = CryptoJS.AES.decrypt(encrypted, this.secret);
        const decoded = JSON.parse(bytes.toString(CryptoJS.enc.Utf8));
        console.log('‚úÖ Usuario autenticado:', decoded);

        if (!decoded) {
          console.warn('‚ùå Cookie vac√≠a o corrupta');
          return auth ;
        }

        // ‚è≥ Verificar expiraci√≥n
        const now = Math.floor(Date.now() / 1000);
        if (decoded.exp && decoded.exp < now) {
          console.warn('‚ùå Token expirado');
          return auth;
        }

        auth=true;
        return auth;
      } catch (err) {
        console.error('‚ùå Error al validar cookie:', err);
        return auth;
      }
    }


    public getUserUuid(): string {
      let  user_uuid:string="850c7f57-6e71-4b56-ad23-96fff3033ef7";
      return user_uuid;
      // const encrypted :string | null = this.cookieService.getCookie(this.userCookieName);
      // if (!encrypted) {
      //   console.warn(this.userCookieName+'‚ùå No existe cookie de sesi√≥n');
      //   return user_uuid;
      // }

      // try {
      //   // üîì Descifrar cookie
      //   const bytes = CryptoJS.AES.decrypt(encrypted, this.secret);
      //   const decoded = JSON.parse(bytes.toString(CryptoJS.enc.Utf8));
      //   user_uuid=decoded.user_uuid;
      //   console.log('‚úÖ Usuario autenticado:',user_uuid);
      //   if (!decoded) {
      //     console.warn('‚ùå Cookie vac√≠a o corrupta');
      //     return user_uuid ;
      //   }
      // return user_uuid;
      // } catch (err) {
      //   console.error('‚ùå Error al validar cookie:', err);
      //   return user_uuid;
      // }
    }
    /**
     *
     */

  /** Limpia estado local */
  clear() {
    this.userSignal.set(null);
  }

  /**
   * 1) Env√≠a el ID token de Google al backend (mutaci√≥n googleLogin)
   * 2) El backend valida y (recomendado) emite cookie httpOnly de sesi√≥n
   * 3) Opcionalmente recibes datos del usuario y los guardas para la UI
   */
  googleLogin(idToken: string) {

    const mutation = `
      mutation GoogleLogin($token: String!) {
        googleLogin(token: $token) {
          success
          message
          user { id email nombre photoUrl }
        }
      }
    `;

    // Si tu backend **requiere** Authorization: Bearer para esta mutaci√≥n inicial:
    const headers = new HttpHeaders({
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${idToken}`
    });

    return this.http.post<any>(
      this.apiUrl,
      { query: mutation, variables: { token: idToken } },
      { headers, withCredentials: true } // <- importante para que viaje la cookie httpOnly
    )
    .pipe(
      tap(res => {
        const payload = res?.data?.googleLogin;
        if (payload?.success) {
          const u = payload.user as Usuario | undefined;
          if (u) this.userSignal.set(u);
        } else {
          // Si falla, limpia el estado local
          this.clear();
        }
      })
    );
  }

  logout(email?: string) {
    this.clear();
    //borrar cookie
    this.cookieService.deleteCookie( environment.USER_COOKIE_NAME);

    // (Opcional) mutaci√≥n al backend para cerrar sesi√≥n server-side
    const mutation = `mutation { logout { success message } }`;
    this.http.post<any>(
      this.apiUrl,
      { query: mutation },
      { withCredentials: true }
    ).subscribe({
      next: () => {},
      error: () => {}
    });

    // (Opcional) Revocar consentimiento en Google
    try {
      if (email && typeof google !== 'undefined') {
        google.accounts.id.revoke(email, () => {});
      } else {
        // cancelar prompts/one-tap si hubiese
        google?.accounts?.id?.cancel?.();
      }
    } catch {}

    this.router.navigate(['/login']);
  }
}
